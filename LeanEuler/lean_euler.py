import os

from .CleanTaxParser.parse_cleantax import parse_cleantax
from .Visualizations.euler_input_visualization_nxpd import visualize_euler_input
from .Visualizations.euler_output_visualization_nxpd import visualize as visualize_euler_output
from .ASPEncodings.rcc_encoding import get_rules as rcc_get_rules
from .ASPEncodings.mnpw_encoding import get_rules as mnpw_get_rules
from .lean_euler_helper_funcs import mkdir_p
from PW_explorer.run_clingo import run_clingo
from PW_explorer.load_worlds import load_worlds
from nxpd import draw


class LeanEuler:

    @staticmethod
    def preprocess_clean_tax(clean_tax_lines):
        def is_an_empty_line(line):
            return line.strip() == ''

        def is_a_comment(line):
            return line.strip()[0] == '#'

        preprocessed_data = [line for line in clean_tax_lines if
                             (not is_an_empty_line(line)) and (not is_a_comment(line))]
        return preprocessed_data

    @staticmethod
    def parse_cleantax(clean_tax_lines):

        preprocessed_clean_tax = LeanEuler.preprocess_clean_tax(clean_tax_lines)
        fname = 'jkbdbcjbdhscbjhbsnkjbjshudhcbskncbhsdbcsbdhbcsbcbshjbdcsjbiueryanballps.txt'
        # clean_tax_stream = StringIO()
        # clean_tax_stream.write('\n'.join(preprocessed_clean_tax))
        with open(fname, 'w') as f:
            f.write('\n'.join(preprocessed_clean_tax))
        rel_data, taxes = parse_cleantax(os.path.abspath(fname))
        os.remove(fname)
        return rel_data, taxes

    @staticmethod
    def gen_asp_rules(relations_data, anytree_data, encoding='mnpw', reasoner='clingo'):
        get_rules_func = {'rcc': rcc_get_rules,
                          'mnpw': mnpw_get_rules}[encoding]

        rules_to_write = get_rules_func(relations_data, anytree_data)

        return rules_to_write

    @staticmethod
    def gen_asp_rules_from_cleantax(clean_tax_lines, encoding='mnpw', reasoner='clingo'):
        relation_data, anytree_data = LeanEuler.parse_cleantax(clean_tax_lines)
        return LeanEuler.gen_asp_rules(relation_data, anytree_data, encoding, reasoner)

    @staticmethod
    def visualize_input(rel_data, taxes):
        return visualize_euler_input(rel_data, taxes)

    @staticmethod
    def visualize_input_from_cleantax(cleantax_lines):
        rel_data, taxes = LeanEuler.parse_cleantax(cleantax_lines)
        return LeanEuler.visualize_input(rel_data, taxes)

    @staticmethod
    def generate_pws(euler_asp_rules, num_solutions=0):
        euler_asp_soln, meta_data = run_clingo(clingo_rules=euler_asp_rules, num_solutions=num_solutions)
        # TODO Add meta data, such as column names
        # TODO Add missing dataframes eg. if po_2 doesn't exist, then add an empty df
        pw_rel_dfs, rel_schemas, pw_objs = load_worlds(asp_output=euler_asp_soln, meta_data=meta_data,
                                                       reasoner='clingo')
        return pw_rel_dfs, rel_schemas, pw_objs

    @staticmethod
    def visualize_output(pw_rels_dfs: dict, project_name: str, pws_to_visualize: list):
        return visualize_euler_output(pw_rels_dfs, project_name, pws_to_visualize)

    @staticmethod
    def save_visualizations(graphs: dict, folder_path: str, formats: list=None):
        """
        :param graphs: Dictionary of pw_id (or 'input') --> networkx graph (preferably generated by visualize_output above)
        :param folder_path:
        :param formats: list of formats to output the viz in. Options: ['pdf','gv','png','svg']. Any subset of these
        can be provided. If not provided, all formats are generated.
        :return:
        """
        if not formats:
           formats = ['pdf', 'gv', 'png', 'svg']
        folder_name = os.path.join(folder_path, 'euler_visualization')
        mkdir_p(os.path.abspath(folder_name))
        for pw_id, g in graphs.items():
            for f in formats:
                draw(g, format=f, filename='{}/pw-{}.{}'.format(folder_name, pw_id, f), show='none')
